値渡しする引数では、コピーコンストラクタ以外のコンストラクタも呼ばれる。
値渡しでコンストラクタを呼ばれないようにするには、コンストラクタの宣言に explicit をつける。


引数をひとつだけとるコンストラクタのことを，“変換コンストラクタ（converting constructor）”と呼ぶ．引数をひとつだけとるコンストラクタについては，明示的呼び出しと暗黙的呼び出しの2つの呼び出し方がある． 
たとえば，クラスCに1個の引数をとるコンストラクタC::C(int)が定義されているとすると， 明示的呼び出しと暗黙的呼び出しはそれぞれ次のように記述できる． 
［C::C(int)のように本当に引数が1個だけのコンストラクタ以外に， C::C(const char*, int = 0)のようにデフォルト引数が指定されているために C obj("cstr");のように引数1個だけを与えて呼び出せるコンストラクタも変換コンストラクタになる．］
呼び出しの種類	コード記述例
明示的呼び出し	C obj(10);
暗黙的呼び出し	C obj = 10;
C++では，1個の引数をとるコンストラクタC::C(int)を定義した場合にのみ“C obj = 10;”のような記述が許される （引数を1個とるコンストラクタが定義されていない場合，コンパイル時エラーになる）． よくある間違いとしては，C obj = 10;のように記述すると，C::operator=(int)が呼び出されるのではないかという誤解があるが， 実際にはC obj = 10;はオブジェクトの構築を意味する文であって代入文（代入演算子の呼び出し）ではないため， 代入演算子であるC::operator=(int)は関係がない． ［注：C言語以来，変数の初期化構文と代入文に同じ記号を使う伝統からこのような誤解が生じやすい． しかし，冷静に考えてみれば，同じ“=”という記号を用いるといっても， int a[] = {1, 2, 3};やchar str[] = "string";のように，初期化のときだけに使える文法があり， 変数初期化の意味の“=”と代入の意味の“=”は明確に違うものとわかる．］