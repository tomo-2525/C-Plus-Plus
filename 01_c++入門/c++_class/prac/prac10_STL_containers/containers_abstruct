コンテナクラスのデータ構造は、以下の４つに分類される
/************************/   
/* Sequences containers */
/************************/   
・array（静的連続配列）
arrayは固定長のオブジェクトを保持するシーケンスコンテナで、各要素は連続して格納される。従来のCスタイルの配列のパフォーマンスを保ったまま、シーケンスのサイズの取得、要素の代入のサポートなど、標準コンテナの恩恵を受ける事ができる。

・vevtor（動的連続配列）
vectorコンテナは可変長配列として実装される。通常の(new []で確保した)配列と同じように、vectorの各要素は連続して配置されるため、イテレータだけでなく添字による要素のランダムアクセスも高速である。

・deque（二重終端キュー）
vector と deque は共に類似したインターフェイスを提供するため、類似した目的に利用することができるが、内部的にはかなり異なった方法で動作する。vector は通常の配列と非常によく似ており、容量が使い果たされるときにはブロック内の全ての要素を再配置することによって拡張する。deque は全ての情報を保持しつつ要素への均一なアクセスを提供することで、要素をストレージのいくつかのチャンクに分割することができる。従って deque の内部は少し複雑であるが、これは特に大規模なシーケンスにおいて大規模な再配置が回避されることを許すため、一般に容量増加の自動管理を vector より効率的に行うことを可能にする。

・forward_list（単方向連結リスト）
forward_listは、標準ライブラリではシーケンスコンテナの一種として定義されるが、いくつかの点でシーケンスコンテナの要件を満たさない
①size()メンバ関数を提供しない。
→size()メンバ関数は全てのコンテナにO(1)計算量を要求するため、単方向リストの実装ではサイズのためのメンバ変数が必要になる。forward_listでは、サイズメンバ変数を内部に持たないことを示すためにsize()メンバ関数は提供しない。要素数が必要な場合はdistance()を使用して取得する。
②insert()/emplace()/erase()メンバ関数を提供しない。
→双方向リンクリストであるlistのinsert()／emplace()／erase()はinsert-before方式をとっておりO(1)計算量だが、単方向リストの典型的なinsert-beforeの実装ではO(N)計算量になってしまう。
forward_listでは、単方向リンクリストでO(1)計算量であるinsert-after方式を使用することを示すinsert_after()／emplace_after()／erase_after()メンバ関数を提供する。先頭に挿入するためにbefore_begin()メンバ関数を提供する。

・list（双方向連結リスト）
任意の位置への挿入や削除を定数時間で行う事が出来るが、高速なランダムアクセスは出来ず、常にシーケンシャルアクセスを行う必要がある。
/**************************/   
/* Associative containers */
/**************************/   

・set
・multiset
<set>ヘッダは、集合を表す連想コンテナ、setとmultisetを定義する。
setはキーの重複を許可しないが、multisetはキーの重複を許可する。
連想コンテナは特にそれらキーによる要素アクセスが効率的になるようよう設計されたコンテナである（要素への相対位置または絶対位置によるアクセスが効率的であるシーケンシャルコンテナとは異なる）。 内部的には、set 内の要素は、コンテナの構築時に設定された狭義の弱順序基準に従って小さいものから大きいものへとソートされる。

・map
・multimap
mapとmultimapはユニークな要素を格納する連想コンテナの一種であり、キーとそれに対応する値を格納する。 mapはキーの重複を許さず、multimapはキーの重複を許す。 
連想コンテナは特にそれらキーによる要素アクセスが効率的になるようよう設計されたコンテナである（要素への相対位置または絶対位置によるアクセスが効率的であるシーケンシャルコンテナとは異なる）。 内部的には、map 内の要素は、コンテナの構築時に設定された狭義の弱順序基準に従って小さいものから大きいものへとソートされる。



/************************************/   
/* Unordered associative containers */
/************************************/   
・unordered_set
<set> と異なり、各要素はキーの順序ではなくキーのハッシュ値に基づいて格納されるため、イテレータを用いたコンテナの走査の順序は（名前の通り）有意ではない。<unordered_set> ヘッダで提供されるコンテナは、operator== と operator!= を除いてコンテナとしての要件を満たす。

・unordered_map
<unordered_map> ヘッダは、キーと値のペアが要素である非順序連想コンテナを提供する。<map> と異なり、各要素はキーの順序ではなくキーのハッシュ値に基づいて格納されるため、イテレータを用いたコンテナの走査の順序は（名前の通り）有意ではない。
<unordered_map> ヘッダで提供されるコンテナは、operator== と operator!= を除いてコンテナとしての要件を満たす。

・unordered_multiset
略

・unordered_multimap
略

/**********************/   
/* Container adaptors */
/**********************/   
・stack
stack はコンテナアダプタであり、LIFO (last-in first-out) の動作――コンテナの一方から要素が挿入され、挿入された側から要素を取り出す――を実現する目的で設計されている。要素をコンテナの back() 側から挿入し、同じく back() 側から取り出す。
stack は、所定のメンバ関数を持つコンテナのオブジェクトを内部実装として用いており、標準のコンテナ、もしくは独自に実装したコンテナを指定することができる。 このコンテナに必要な要件は、以下のメンバ関数を持つことである。
back()
push_back()
pop_back()
emplace_back() (C++11)

・queue
queueはコンテナアダプタであり、FIFO (first-in first-out) の動作――コンテナの一方から要素が挿入され、反対側から要素を取り出す――を実現する目的で設計されている。要素をコンテナの back() 側から挿入し、front() 側から取り出す。
queue は、所定のメンバ関数を持つコンテナのオブジェクトを内部実装として用いており、標準のコンテナ、もしくは独自に実装したコンテナを指定することができる。
このコンテナに必要な要件は、以下のメンバ関数を持つことである。
front()
back()
push_back()
pop_front()
emplace_back() (C++11)
この要件を満たすものとしては deque と list があり、デフォルトではdequeが使用される。

・priority_queue
priority_queueはコンテナアダプタであり、優先順位付きキューを実現する目的で設計されている。要素をpush()で追加し、取り出す際にtop()を呼び出すことで、Compare述語によって優先順に要素が取り出される。デフォルトでは降順に処理される。priority_queueは、所定のメンバ関数を持つコンテナのオブジェクトを内部実装として用いており、標準のコンテナ、もしくは独自に実装したコンテナを指定することができる。
このコンテナに必要な要件は、ランダムアクセスイテレータを持ち、かつ以下のメンバ関数を持つことである。
front()
push_back()
pop_back()
emplace_back() (C++11)