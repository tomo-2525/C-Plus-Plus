push_backとemplace_backは引数と実行速度が異なり、操作結果は変わらない
それは、なぜかというと、

class Minute{
    ...
public:
    Minute(int time);
    ...
};

std::vector<Minute> vec;
vec.push_back(12);

このとき、内部では以下のように動作しています。
①一時オブジェクトが12からコンストラクトされる
②それがpush_backの仮引数へムーブされ、それがstd::vectorの新規オブジェクトとしてコンストラクトされる。
③一時オブジェクトが破棄される。

このようにコンストラクトが２回起きています。これは、無駄になります。

template<class T,class Allocator = allocator<T>>
class vector {
public:
    ...
    template<class ...U>
    void emplace_back(U&&... param);
    ...
};
この関数は、内部で完全転送というものを行っています。
完全転送とは、


/******************/
/* 右辺値・左辺値 */
/******************/
int z = f(x, g(y));
x, y, z：左辺値
g(y), f(x, g(y))：右辺値
左辺値・右辺値それぞれの参照は左辺値参照(lvalue reference)と右辺値参照(rvalue reference)で、*通常は*、前者がT&で後者がT&&と書かれます。

int& y = x; // 左辺値参照
int&& y = g(x); // 右辺値参照

ここであえて*通常は*と言ったのは、T&&で宣言しても左辺値になることがあるからです。

void f(int&& v)
{
    // vはT&&（右辺値参照）で宣言しているのに、アドレス取得できるので、実はvは左辺値です！
    // ∵すべての関数の引数は左辺値だから
    std::cout << &v << std::endl;
}

説明中にT&&が出てきても右辺値とは限らないことがあることは念頭においておいてください（逆に、T&&が毎回出てきた時に、毎回、それが右辺値か左辺値かを考えていると、理解が進むかもしれません）。

/******************/
/* ムーブ・コピー */
/******************/
ムーブ(move)は、コピー(copy)の対になる概念で、コピーが複製なのに対して、ムーブは置換（複製＆破棄）を意味します。
RPGツクールで物体の移動をやりたい時に「移動」というコマンドがなくて「複製してから消せばいい」と書いてあったあれがムーブです。

このムーブを実現するコンストラクタおよび代入演算子をムーブコンストラクタとムーブ代入演算子と呼びます。

{
    const int y = x;
    const int z = x;
    int ret = 0;
    ret = y+z;
}

↑の時、代入演算=のうち、y=xの=はコピー代入である必要があります。一方、z=x, ret=0, ret=y+zの=は、（コピー代入でもいいですが）xやy+zの結果を捨ててもいい（後で使わない）のでムーブ代入にしてもよいはずです。